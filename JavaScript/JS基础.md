## 基本概念

1. JS区分大小写；函数名不能适用`typeof`，它是一个关键字。

2. 标识符就是指变量、函数、属性的名字，或者函数的参数。

3. JS注释

   ```javascript
   // 单行注释
   /**
   * 这是多行注释
   * (块级)注释
   */
   ```

4. 严格模式：为`JavaScript`定义了一种不同的解析与执行模式。是ES5引入的一个概念，处理了ES3的一些不确定行为。整个脚本中使用或函数内部使用，分别加如下代码：

   ```javascript
   // 整个脚本中，在顶部加
   "use strict"
   // 函数内部
   function doSomething() {
       "use strict"
       // 函数体
   }
   ```

5. JS语句以分号结尾，如果分号省略，则由解析器确定语句的结尾；建议任何时候都不要省略分号。

6. JS变量类型是松散类型的，即可以用来保存任何类型的数据，每个变量仅仅是一个用于保存值的占位符而已。

7. JS有5种基本数据类型：`Undefined`、`Null`、`Boolean`、`Number`和`String`;还有一种复杂的数据类型`Object`，它本质上是由一组无序的名值对组成的。

8. `typeof`是操作符，而不是函数。它用来检测给定变量的数据类型。`typeof`可能返回的字符串：

   - "undefined"：如果这个值未定义；
   - "boolean"：如果这个值是布尔值；
   - "string"：如果这个值是字符串；
   - "number"：如果这个值是数值；
   - "object"：如果这个值是对象或`null`；`null`会被认为是一个空的对象引用
   - "function"：如果这个值是函数。

9. `Undefined`类型只有一个值，即`undefined`。它是在第三版引入为了区分空对象指针与未经初始化的变量。初始声明的未赋值或赋值`undefined`的变量是`undefined`;但与尚未定义的变量是不同的。

   ```javascript
   let message;
   // 下面变量未声明
   // let age;
   alert(message); // “undefined”
   alert(age);     // 产生错误
   
   alert(typeof message)； // “undefined”
   alert(typeof age)；     // “undefined”
   ```

   然而，对未初始的变量执行`typeof`操作符会返回`undefined`值，对未声明的变量进行此操作结果也是`undefined`。

10. `Null`类型也只有一个值，即`null`。从逻辑角度看，`null`表示一个空对象指针，这也正式为什么使用`typeof`操作符监测null值会返回"object"的原因。**如果定义的变量用于保存对象，那么最好将该变量初始化为null而不是其他值。**这样一来直接检查`null`值就可以知道相应的变量是否已保存了一个对象的引用。也就是，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存为`null`。这样做不仅体现`null`作为空对象指针的管理，而且有利于进一步区分`null`和`undefined`。

11. `Boolean`类型有两个字面值:`true`和`false`。可以对任何数据类型的值调用`Boolean()`函数，而且总会返回一个`Boolean`值，该值被保存在`messageAsBoolean`变量中。

12. `Number`类型使用了`IEEE754`格式来表示整数和浮点数。JS能够标识的最大数值保存在`Number.MIN_VALUE`中，值是`5e-324`；能够标识最大的值保存在`Number.MAX_VALUE`中，值是`1.7976931348623157e+308`。超出此范围的值会被转换为`Infinity`和`-Infinity`。可以使用`isFinite()`函数，函数在参数位于最小与最大数值之间时会返回`true`。

13. `NaN`是一个特殊的数值，即非数值（Not a Number），这个数值用于标识一个本来要返回数值的操作数未返回数值的情况。`isNaN()`函数可以确定参数是否“不是数值”。`NaN`有两个特点：

    - 任何涉及`NaN`的操作都会返回`NaN`；
    - `NaN`与任何值都不相等，包括`NaN`本身。

14. 数值转换，有3个函数可以把非数值转换为数值：`Number()`、`parseInt()`、`parseFloat()`。

15. `String`类型用于表示由零或多个16位`Unicode`字符组成的字符序列，即字符串。`String`类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符或有其他用途的字符：`\n \t \b \r \f \\ \' \"`。

16. 字符串是不可变的，字符串一旦创建，他们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。

17. 转换为字符串的方法，几乎每个值都有`toString()`方法，包括：数值、布尔值、对象、字符串。但`null`和`undefined`值没有这个方法。默认情况下，该方法以十进制返回字符串，同事支持二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。

    ```javascript
    var num = 10;
    alert(num.toString());    // "10"
    alert(num.toString(2));   // "1010"
    alert(num.toString(8));   // "12"
    alert(num.toString(10));  // "10"
    alert(num.toString(16));  // "a"
    ```

    另一个方法是`String()`，这个函数能转换任何类型的值为字符串。遵循的转换规则：

    - 如果值有`toString()`方法，则调用该方法并返回相应结果；
    - 如果是`null`，则返回"null"；
    - 如果是`undefined`，则返回"undefined"。

18. `Object`类型是一组数据和功能的集合。它是所有它的实例的基础，即`Object`类型所具有的任何属性和方法也同样存在于更具体的对象中。每个实例都具有下列的属性和方法：

    - `constructor`：构造函数，保存着创建当前对象的函数；
    - `hasOwnProperty(propertyName)`：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在；
    - `isPrototypeOf(object)`：检查传入的对象是否是传入对象的原型；
    - `propertyIsEnumerable(propertyName) `：检查给定的属性是否能够用`for-in`语句来枚举。
    - `toLocalString()`：返回对象的字符串表示，该字符串与执行环境的地区对应；
    - `toString()`：返回对象的字符串表示；
    - `valueOf()`：返回对象的字符串、数值或布尔值表示。通常与`toString()`方法的返回值相同。

19. 操作符用于操作数值：包括算数操作符、位操作符、关系操作符、相等操作符。

    - 一元操作符：递增`++`、递减`—`、加`+`、减`-`；

    - 位操作符：JS中的所有数值都是以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值，而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。对于有符整数，第32位表示符号，0 表示整数，1表示负数。负数使用的是二进制补码。

      1. 按位非`~`：返回数值的反码；
      2. 按位与`&`：对应位都是1返回1，任何一位是0，结果返回0；
      3. 按位或`|`：有一个位是1就返回1，只有两个位是0才返回0；
      4. 按未异或`^`：只有一个1时才返回1，两个位都是1或都是0，返回0；
      5. 左移`<<`：将数值的所有位向左移动指定的位数；
      6. 有符右移`>>`：将数值向右移动，但保留符号位；在右移过程中会出现空位，空位在原数值的左侧、符号位右侧，此时会用**符号位的值**来填充所有空位；
      7. 无符号右移`>>>`：将数值的所有32位向右移动；对正数来说，结果与有符右移相同。对于负数，无符号右移以0来填充空位，而不是像有符号右移以符号位的值来填充空位。无符右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值的二进制码补码形式存在，因此就会导致无符号右移后的结果非常之大。如：`-64`的二进制码为`11111111111111111111111111000000 `，无符右移之后会把二进制码当成正数的二进制码，换算成十进制就是`4294967232 `，右移5位之后就成了`00000111111111111111111111111110 `即十进制`134217726`。

    - 布尔操作符：布尔操作符一共有3个：与`&&`、或`||`、非`!`；

    - 乘性操作符：乘法、除法、求模；

    - 加性操作符：加法、减法；

    - 关系操作符：小于、大于、小于等于、大于等于；

    - 相等操作符：相等`==`和不相等`!=`，先转换再比较；全等`===`和不全等`!==`，仅比较不转换，推荐使用。

      - 相等和不相等：先强制转型，再比较相等性
      - 全等和不全等：两个操作数未经转换就相等的情况下返回`true`

    - 条件操作符：`variable = boolean_expression ? true_value : false_value;`

    - 赋值操作符：把右侧的值赋值给左侧的变量。下面是简化的复合赋值操作符，这些操作符的主要目的是简化赋值操作，不会带来任何性能的提升。

      ```javascript
      = *= /= %= += -= <<= >>= >>>=
      ```

    - 逗号操作符：可以在一条语句中执行多个操作，如

      ```javascript
      let a = 1, b = 2, c = 3;
      ```

20. `label`语句，使用label语句可以再代码中添加标签，以便将来使用：`label: statement`。例子：定义start标签，可以再将来由break或continue语句引用。加标签的语句一般都要与for语句等循环语句进行配合使用。

    ```javascript
    start: for(let i=0; i < count; i++){
        console.log(i);
    }
    ```

21.  函数参数：JS函数的参数不介意传进来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数，在调用这个函数时也未必一定要传递两个参数。可以传递一个或三个，解析器都可以解析。因为JS中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数。在函数体内可以通过`arguments`对象来访问这个参数数组，从而获取传递函数的每个参数。没有传递值的命令参数将自动被赋予`undefined`值，这就跟定义了变量但又没有初始化一样。

22. 函数没有重载：在其他语言中，可以为一个函数编写两个定义，只要两个定义的签名（接受的参数的类型和数量）不同即可。JS函数没有签名，因为参数是由包含零或多个值的数组来表示的。如果函数名字相同，之后定义的函数会覆盖先定义的函数。

    

## 变量

1. 定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值。但是对不同类型值进行操作是不一样的，对于引用类型我们可以为其添加属性和方法，也可以改变和删除其属性和方法。但是我们不能给基本类型添加属性或方法，尽管这样做不会导致错误。

2. 复制变量值：如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。当一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。

3. 传递参数：JS所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。在向参数传递基本类型值的值时，被传递的值会被复制给一个局部变量。在向参数传递引用类型时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。

4. 检测类型：`typeof`在检测基本数据类型时很有用，但在检测引用类型的值时，它的用处不大。通常，我们并不想知道某个值是对象，而是想知道它是什么类型的对象。JS提供了`instanceof`操作符，语法如下：

   ```javascript
   result = variable instanceof constructor
   ```

   如果变量是给定引用类型的实例，那么`instanceof`操作符就会返回`true`。根据规定，所有引用类型的值都是`Object`的实例。因此在检测一个引用类型值和`Object`构造函数时，`instanceof`操作符始终会返回`true`。检测基本类型的值，会返回`false`，因为基本类型不是对象。

   ```javascript
   // 变量person是Object吗
   alert(person instanceof Object); 
   // 变量colors是Array吗
   alert(colors instanceof Array); 
   alert(patterninstanceofRegExp); 
   ```

   ## 引用类型

   

