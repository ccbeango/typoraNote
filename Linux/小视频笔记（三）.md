# 小视频笔记(三)

[TOC]

# 8 权限管理

## 8.1 ACL权限

### 1.权限简介

Linux的文件有所有者，所属组，其他人三种权限，但这是远远不够的，比如说，有一个project，项目管理员将所有项目人员添加到该项目的所属组中，分配权限770，有一天，临时来了一个成员，该成员需要先进行学习，然后才能工作，这时我们需要对该成员对project分配读和可执行的权限，不能将其他人权限设为5，文件只有一个所属组，所以对project分配两个所属组的方式不成立，显然此时的权限管理方式无法满足要求，这时候就用到ACL权限了，所谓的ACL权限，可以简单的理解为为某一用户或某一组分配不属于所有，所属组，其他人的额外权限。

![](./images/linux小视频04.png)

### 2.查看分区ACL权限是否开启

```shell
# 查看分区使用状况
~ andy$ df -h
Filesystem      Size   Used  Avail Capacity iused      ifree %iused  Mounted on
/dev/disk1     112Gi   61Gi   51Gi    55% 1632930 4293334349    0%   /
devfs          182Ki  182Ki    0Bi   100%     632          0  100%   /dev
map -hosts       0Bi    0Bi    0Bi   100%       0          0  100%   /net
map auto_home    0Bi    0Bi    0Bi   100%       0          0  100%   /home
```

命令格式：`dumpefs [选项] 分区路径`

​	查询指定分区详细文件系统信息的命令 

选项: 

​	-h 仅显示超级块中信息，而不显示磁盘块组的详细信息 

```shell
 dumpe2fs -h /dev/sda3
 
```

### 3.临时开启分区ACL权限

``` shell
# 重新挂载根分区，并挂载加入acl权限
[root@localhost ~]# mount -o remount,acl /
```

### 4.永久开启分区ACL权限

```shell
[root@localhost ~]# vi /etc/fstab
UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 defaults,acl #加入acl
[root@localhost ~]# mount -o remount /
#重新挂载文件系统或重启动系统，使修改生效
```

**注：** fastab是系统开机启动默认挂载的文件

### 5. 设定ACL权限的命令

命令：`setfacl 选项 文件名` 设置ACL权限

选项：

* -m       设定ACL权限
* -x         删除指定的ACL权限
* -b         删除所有的ACL权限
* -d         设定默认ACL权限
* -k          删除默认ACL权限
* -R         递归设定ACL权限

命令：`getacl 路径` 查看ACL权限

准备工作，创建需要的用户和用户组

```shell
[root@262e395bc9e9 ~]# useradd zhangsan
[root@262e395bc9e9 ~]# useradd lisi
[root@262e395bc9e9 ~]# useradd st
[root@262e395bc9e9 ~]# groupadd tgroup
[root@262e395bc9e9 ~]# mkdir /tmp/project
[root@262e395bc9e9 ~]# chown root:tgroup /tmp/project/
[root@262e395bc9e9 ~]# chmod 770 /tmp/project/
```

给用户设定ACL权限

```shell
# 给用户st赋予r-x权限，使用“u:用户名:权限”格式
[root@262e395bc9e9 ~]# setfacl -m u:st:rx /tmp/project
# 设定结果 多了个“+”
[root@262e395bc9e9 ~]# ll -d
drwxrwx---+ 2 root tgroup 4096 Aug  9 07:22 /tmp/project
[root@262e395bc9e9 project]# getfacl .
# file: .
# owner: root
# group: tgroup
user::rwx
user:st:r-x
group::rwx
mask::rwx
other::---

# 切换用户测试 没有w权限
[root@262e395bc9e9 project]# su - st
[st@262e395bc9e9 ~]$ cd /tmp/project/
[st@262e395bc9e9 project]$ touch test.js
touch: cannot touch 'test.js': Permission denied
```

给用户组设定ACL权限

```shell
[root@262e395bc9e9 project]# groupadd tgroup2
[root@262e395bc9e9 project]# setfacl -m g:tgroup2:rwx /tmp/project
[root@262e395bc9e9 project]# getfacl /tmp/project
getfacl: Removing leading '/' from absolute path names
# file: tmp/project
# owner: root
# group: tgroup
user::rwx
user:st:r-x
group::rwx
group:tgroup2:rwx
mask::rwx
other::---
```

### 6.最大有效权限与删除

​	最大有效权限mask：mask是用来指定最大有效权限的。如果 我给用户赋予了ACL权限，是需要和 mask的权限“相与”才能得到用户的真正权限 。

```shell
[root@262e395bc9e9 project]# setfacl -m m:rx /tmp/project
[root@262e395bc9e9 project]# getfacl /tmp/project
getfacl: Removing leading '/' from absolute path names
# file: tmp/project
# owner: root
# group: tgroup
user::rwx
user:st:r-x
group::rwx			    #effective:r-x
group:tgroup2:rwx		#effective:r-x
mask::r-x
other::---
```

它并不影响所有者的权限，而是影响所属组和ACL的权限。

删除ACL权限

```shell
# 删除指定用户的ACL权限
[root@localhost /]# setfacl -x u:用户名 文件名
# 删除指定用户组的ACL权限
[root@localhost /]# setfacl -x g:组名 文件名
```

使用：

```shell
[root@262e395bc9e9 project]# setfacl -x g:tgroup2 /tmp/project
[root@262e395bc9e9 project]# getfacl .
# file: .
# owner: root
# group: tgroup
user::rwx
user:st:r-x
group::rwx
mask::rwx
other::---

[root@262e395bc9e9 project]# setfacl -b /tmp/project
[root@262e395bc9e9 project]# getfacl .
# file: .
# owner: root
# group: tgroup
user::rwx
group::rwx
other::---

# 没“+”
[root@262e395bc9e9 project]# ll -d
drwxrwx--- 2 root tgroup 4096 Aug  9 07:22 .
```

### 7.默认与递归ACL权限

​	递归是父目录在设定ACL权限时，所有的子文件和子目录也会拥有相同的ACL权限。 

```shell
setfacl -m u:用户名:权限 -R 目录
```

​	注：`-R`只能在这个位置，其他位置会报错

使用：

```shell
[root@262e395bc9e9 project]# setfacl -m u:st:rx -R /tmp/project 
[root@262e395bc9e9 project]# ll -a
total 16
drwxrwx---+ 4 root tgroup 4096 Aug  9 08:26 .
drwxrwxrwt  1 root root   4096 Aug  9 07:22 ..
drwxr-xr-x+ 2 root root   4096 Aug  9 08:25 test1
drwxr-xr-x+ 2 root root   4096 Aug  9 08:26 test2
```

​	默认ACL权限：如果给父目录设定 了默认ACL权限，那么父目录中所有新建 的子文件都会继承父目录的ACL权限 。这个操作只会对新创建在目录下的文件生效，对现有的文件无影响，如果现有文件也需要设置ACL权限，需要使用递归赋予权限。

```shell
setfacl -m d:u:用户名:权限 文件名
```

​	注：`d`指的是`default`

使用：

```shell
[root@262e395bc9e9 project]# setfacl -m d:u:st:rx /tmp/project
[root@262e395bc9e9 project]# mkdir test3 
[root@262e395bc9e9 project]# getfacl test3
# file: test3
# owner: root
# group: root
user::rwx
user:st:r-x
group::rwx
mask::rwx
other::---
default:user::rwx
default:user:st:r-x
default:group::rwx
default:mask::rwx
default:other::---
```

## 8.2 文件特殊权限

### 1.SetUID

### 2.SetUID

### 3.Sticky BIT

## 8.3 文件系统属性权限

### chattr

| 名称     | 说明                               |
| -------- | ---------------------------------- |
| 命令名称 | chattr                             |
| 原意     | change attributes                  |
| 所在路径 | /usr/bin/chattr                    |
| 功能描述 | 更改系统文件属性                   |
| 语法     | chattr [+-=].  [选项] 文件或目录名 |

`+:增加权限 -：删除权限 =：等于某权限`

选项说明:

* `i`: 如果对文件设置i属性，那么不允许对文件进行删除、改名，也不能添加和修改数据;如果对目录设置i属性，那么只能修改目录下文件的数据，但不允许建立和删除文件 。
* `a`: 如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除也不能修改数据(数据增加只能是追加的方式);如果对目录设置`a`属性，那么只允许在目录中建立和修改文件 ，但是不允许删除 。

`chattr`对于保护文件系统当中重要数据免遭误操作是非常有效的。但是可以通过`+-`进行方便的设置是否可以操作，它不是为了限制用户，而是为了防止连在root用户在内的用户进行误操作的措施。

### lsattr

| 名称     | 说明                  |
| -------- | --------------------- |
| 命令名称 | lsattr                |
| 原意     | ls attributes         |
| 所在路径 | /usr/bin/lsattr       |
| 功能描述 | 查看系统文件属性      |
| 语法     | chattr  选项名 文件名 |

选项说明：

* `-a`：显示所有文件和目录
* `-d`：若目标是目录，仅列出目录本身的属性，而不是子文件的

## 8.4 系统命令sudo权限

### sudo

| 名称     | 说明                                             |
| -------- | ------------------------------------------------ |
| 命令名称 | sudo                                             |
| 原意     | super user do                                    |
| 所在路径 | /usr/bin/sudo                                    |
| 功能描述 | root把本来只能超级用户执行的命令赋予普通用户执行 |
| 语法     | sudo 系统命令                                    |

使用：

1. 赋予普通用户权限或用户组权限

```shell
# 实际修改的是/etc/sudoers文件 直接用vi修改这个文件也可以
[root@262e395bc9e9 tmp]# visudo

# 用户名 被管理主机的地址=(可使用的身份)  授权命令(绝对路径)
root ALL=(ALL)          ALL

# %组名 被管理主机的地址=(可使用的身份)   授权命令(绝对路径)
%wheel  ALL=(ALL)       ALL
```

`ALL=(ALL)`第一个`ALL`并不是定义允许哪个ip地址或网络允许访问我们，而是定义允许哪一个用户在哪一台计算机上执行某一条命令，即写的是被管理主机的地址。限制的是访问IP而不是来源IP。第二个`ALL`指的是可使用的用户。第三个`ALL`标识授权命令，写ALL其实是不合理的，赋予的能力过于强大，正常来讲，应该写具体哪个命令，使用的是绝对路径。

```shell
[root@262e395bc9e9 tmp]# visudo
sc ALL= /sbin/shutdown –r now
# 赋予sc此权限很危险，用户可以操作任何文件。不过看公司使用全都给的ALL。。。
sc ALL=/usr/bin/vim
```

注意：如果命令写的越简单，代表用户具有的权限越大。比如说上面的命令没有写`-r now`代表用户可以执行`shutdown`的所有参数。即命令可以根据需求，进行修改。

`sudo -l`可查看拥有的权限

